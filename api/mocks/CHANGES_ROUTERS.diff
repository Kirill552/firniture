--- a/api/routers.py
+++ b/api/routers.py
@@ -33,6 +33,10 @@ from shared.spec_extraction import create_spec_extraction_service
 from shared.embeddings import embed_text, concat_product_config_text
 from api.vector_search import find_similar_hardware
 from shared.yandex_ai import rank_hardware_with_gpt
+from api.mocks.dialogue_mocks import (
+    are_yc_keys_available,
+    generate_mock_dialogue_response
+)

 log = logging.getLogger(__name__)

@@ -57,9 +61,16 @@ def export_1c(req: Export1CRequest) -> Export1CResponse:
 @dialogue_router.post("/clarify")
 async def dialogue_clarify(req: DialogueTurnRequest, db: AsyncSession = Depends(get_db)) -> StreamingResponse:
     """
     Принимает текущую историю диалога и возвращает потоковый ответ от ИИ-технолога.
+
+    Если YC_FOLDER_ID и YC_API_KEY не заданы — использует mock ответы для локальной разработки.
     """
     order = await crud.get_order_with_history(db, req.order_id)
     if not order:
         raise HTTPException(status_code=404, detail="Order not found")

+    # Проверяем наличие Yandex Cloud ключей
+    use_mock_mode = not are_yc_keys_available()
+
+    if use_mock_mode:
+        log.warning(f"[MOCK MODE] YC keys not found. Using mock dialogue responses for order {req.order_id}")
+
+    # Добавляем новые сообщения из запроса в БД
+    current_turn = (order.dialogue_messages[-1].turn_number + 1) if order.dialogue_messages else 1
+    user_message_text = ""
+    for user_msg in req.messages:
+        user_message_text = user_msg.content  # Сохраняем последнее сообщение пользователя
+        await crud.create_dialogue_message(db, order.id, current_turn, user_msg.role, user_msg.content)
+
+    # MOCK РЕЖИМ - используем заготовленные ответы
+    if use_mock_mode:
+        async def mock_response_generator():
+            full_response = ""
+            is_first_message = current_turn == 1
+
+            try:
+                async for chunk in generate_mock_dialogue_response(
+                    order_id=order.id,
+                    user_message=user_message_text,
+                    is_first_message=is_first_message
+                ):
+                    full_response += chunk
+                    yield chunk
+
+                # Сохраняем полный mock ответ в БД
+                await crud.create_dialogue_message(db, order.id, current_turn, "assistant", full_response)
+                log.info(f"[MOCK MODE] Mock response saved to DB for order {order.id}")
+
+            except Exception as e:
+                log.error(f"[MOCK MODE] Mock dialogue generation failed for order {req.order_id}: {e}")
+                yield "\n\n[ОШИБКА] Не удалось сгенерировать mock ответ."
+
+        return StreamingResponse(mock_response_generator(), media_type="text/plain")
+
+    # PRODUCTION РЕЖИМ - используем YandexGPT
     # 1. Собираем историю для YandexGPT
     try:
         with open("docs/ai_dialogue_spec.md", "r", encoding="utf-8") as f:
@@ -75,18 +86,11 @@ async def dialogue_clarify(req: DialogueTurnRequest, db: AsyncSession = Depends
         raise HTTPException(status_code=500, detail="AI dialogue spec file not found.")

     messages = [{"role": "system", "text": system_prompt_text}]
-
+
     # Добавляем историю из БД
     for msg in sorted(order.dialogue_messages, key=lambda m: m.turn_number):
         messages.append({"role": msg.role, "text": msg.content})

-    # Добавляем новые сообщения из запроса
-    current_turn = (order.dialogue_messages[-1].turn_number + 1) if order.dialogue_messages else 1
-    for user_msg in req.messages:
-        messages.append({"role": user_msg.role, "text": user_msg.content})
-        await crud.create_dialogue_message(db, order.id, current_turn, user_msg.role, user_msg.content)
-
-    # 2. Готовимся к стримингу ответа
+    # 2. Готовимся к стримингу ответа от YandexGPT
     yc_settings = YandexCloudSettings(
         yc_folder_id=os.getenv("YC_FOLDER_ID", ""),
         yc_api_key=os.getenv("YC_API_KEY", "")
@@ -95,14 +99,15 @@ async def dialogue_clarify(req: DialogueTurnRequest, db: AsyncSession = Depends
     async def response_generator():
         full_response = ""
         try:
+            log.info(f"[PRODUCTION MODE] Using YandexGPT for order {req.order_id}")
             async with create_gpt_client(yc_settings) as client:
                 async for chunk in client.stream_chat_completion(messages):
                     full_response += chunk
                     yield chunk
-
+
             # 3. Сохраняем полный ответ ассистента в БД
             await crud.create_dialogue_message(db, order.id, current_turn, "assistant", full_response)

         except Exception as e:
             log.error(f"Dialogue clarification failed for order {req.order_id}: {e}")
             yield "\n\n[ОШИБКА] Не удалось получить ответ от ИИ-ассистента."
