"""
Генератор G-code для ЧПУ станков мебельного производства.

Профили станков оптимизированы для российского рынка (2024-2025):
- Weihong NCStudio (~30-35% рынка) — лидер в бюджетном сегменте
- Syntec (~20-25% рынка) — растущий, KDT/WoodTec, FANUC-совместимый
- FANUC (~15-20% рынка) — премиум, ISO 7-bit стандарт
- DSP A11/A18 (~8-12% рынка) — бюджетные станки
- HOMAG — премиум мебельное оборудование

Источник: Perplexity Deep Research, январь 2025
- КАМИ (stanki.ru), ЛИГА Machinery, Интервесп
- Техдокументация Weihong, FANUC, Syntec
"""
from __future__ import annotations

import io
import math
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Literal

from api.constants import (
    DEFAULT_BACK_SLOT_DEPTH_MM,
    DEFAULT_BACK_SLOT_WIDTH_MM,
    DEFAULT_DRILLING_DEPTH,
)

try:
    import ezdxf
    EZDXF_AVAILABLE = True
except ImportError:
    EZDXF_AVAILABLE = False


class MachineType(str, Enum):
    """Типы поддерживаемых систем ЧПУ для мебельного производства."""
    WEIHONG = "weihong"       # NCStudio — лидер рынка (~30-35%)
    SYNTEC = "syntec"         # KDT, WoodTec (~20-25%)
    FANUC = "fanuc"           # Премиум, ISO стандарт (~15-20%)
    DSP = "dsp"               # Бюджетный сегмент (~8-12%)
    HOMAG = "homag"           # Премиум мебельное оборудование


@dataclass
class MachineProfile:
    """Профиль настроек ЧПУ станка для мебельного производства."""
    name: str
    machine_type: MachineType

    # Скорость шпинделя (об/мин) — для мебели 8000-20000 RPM
    spindle_speed: int = 18000

    # Подача (мм/мин) — из исследования
    feed_rate_cutting: int = 600       # Резка листов: 400-900 mm/min
    feed_rate_plunge: int = 300        # Врезание: 200-400 mm/min
    feed_rate_drilling: int = 300      # Сверление: 200-400 mm/min
    feed_rate_rapid: int = 6000        # Быстрое перемещение

    # Глубины (мм)
    safe_height: float = 5.0           # Безопасная высота
    cut_depth: float = 18.0            # Глубина резки (ЛДСП 16-18мм)
    step_down: float = 6.0             # Шаг по глубине

    # Инструмент
    tool_diameter: float = 6.0         # Диаметр фрезы (мм)
    tool_number: int = 1               # Номер инструмента

    # Сверление (присадка)
    drill_peck_depth: float = 5.0      # Глубина пека G83
    drill_retract: float = 2.0         # R параметр — отвод

    # Специфичные настройки
    use_coolant: bool = False
    use_tool_change: bool = True
    use_line_numbers: bool = False
    line_number_increment: int = 10

    # Синтаксис комментариев
    comment_start: str = "("
    comment_end: str = ")"

    # Единицы G04 (КРИТИЧНО для Weihong!)
    dwell_unit: Literal["seconds", "milliseconds"] = "seconds"

    # Постпроцессор
    program_start: list[str] = field(default_factory=list)
    program_end: list[str] = field(default_factory=list)


# =============================================================================
# Предустановленные профили станков для российского рынка
# Источник: Perplexity Deep Research (январь 2025)
# =============================================================================

MACHINE_PROFILES: dict[str, MachineProfile] = {
    # -------------------------------------------------------------------------
    # Weihong NCStudio (~30-35% рынка) — ЛИДЕР
    # Бюджетный сегмент, китайские станки, формат ISO 7-bit DSP-compatible
    # КРИТИЧНО: G04 P в МИЛЛИСЕКУНДАХ!
    # -------------------------------------------------------------------------
    "weihong": MachineProfile(
        name="Weihong NCStudio v5.x",
        machine_type=MachineType.WEIHONG,
        spindle_speed=18000,
        feed_rate_cutting=600,
        feed_rate_plunge=300,
        feed_rate_drilling=300,
        safe_height=5.0,
        cut_depth=18.0,
        step_down=6.0,
        tool_diameter=6.0,
        use_tool_change=True,
        use_line_numbers=False,
        comment_start="(",
        comment_end=")",
        dwell_unit="milliseconds",  # КРИТИЧНО! P1500 = 1.5 сек
        program_start=[
            "O0001",  # 4-5 цифр
            "(Weihong NCStudio Program)",
            "(Generated by Mebel-AI)",
            "G21",  # Метрическая система
            "G90",  # Абсолютные координаты
            "G17",  # Плоскость XY
        ],
        program_end=[
            "M05",
            "G00 Z30",
            "G00 X0 Y0",
            "M30",  # или M17 для подпрограмм
        ],
    ),

    # -------------------------------------------------------------------------
    # Syntec (~20-25% рынка) — РАСТУЩИЙ
    # KDT, WoodTec, нестинг-центры. FANUC-совместимый синтаксис
    # -------------------------------------------------------------------------
    "syntec": MachineProfile(
        name="Syntec 60W/200W (KDT/WoodTec)",
        machine_type=MachineType.SYNTEC,
        spindle_speed=18000,
        feed_rate_cutting=800,  # Более производительный
        feed_rate_plunge=400,
        feed_rate_drilling=350,
        safe_height=5.0,
        cut_depth=18.0,
        step_down=6.0,
        tool_diameter=6.0,
        use_tool_change=True,
        use_line_numbers=False,
        comment_start="(",
        comment_end=")",
        dwell_unit="seconds",  # G04 P1 = 1 сек (как FANUC)
        program_start=[
            "O1234",  # Опционально
            "(Syntec CNC Program)",
            "(Generated by Mebel-AI)",
            "G21",
            "G90",
            "G17",
            "G40",  # Отмена компенсации радиуса
        ],
        program_end=[
            "M05",
            "G00 Z25",
            "G00 X0 Y0",
            "M30",
        ],
    ),

    # -------------------------------------------------------------------------
    # FANUC (~15-20% рынка) — ПРЕМИУМ
    # ISO 7-bit стандарт, максимальная совместимость с CAM
    # -------------------------------------------------------------------------
    "fanuc": MachineProfile(
        name="FANUC 0i/31i (ISO 6983)",
        machine_type=MachineType.FANUC,
        spindle_speed=18000,
        feed_rate_cutting=800,
        feed_rate_plunge=400,
        feed_rate_drilling=300,
        safe_height=5.0,
        cut_depth=18.0,
        step_down=6.0,
        tool_diameter=6.0,
        use_tool_change=True,
        use_line_numbers=True,
        line_number_increment=10,
        comment_start="(",
        comment_end=")",
        dwell_unit="seconds",  # G04 P1.5 или G04 X1.5
        program_start=[
            "%",
            "O0001",  # 4 цифры
            "(FANUC ISO Program)",
            "(Generated by Mebel-AI)",
            "G21 G90 G40 G49",
            "G17",
        ],
        program_end=[
            "M05",
            "G28 G91 Z0",
            "G28 X0 Y0",
            "M30",
            "%",
        ],
    ),

    # -------------------------------------------------------------------------
    # DSP A11/A18 (~8-12% рынка) — БЮДЖЕТНЫЙ
    # Простейшие контроллеры, лазерные граверы, минимальные производства
    # -------------------------------------------------------------------------
    "dsp": MachineProfile(
        name="DSP A11/A18",
        machine_type=MachineType.DSP,
        spindle_speed=15000,  # Обычно ниже
        feed_rate_cutting=500,
        feed_rate_plunge=250,
        feed_rate_drilling=250,
        safe_height=3.0,
        cut_depth=16.0,
        step_down=4.0,
        tool_diameter=6.0,
        use_tool_change=False,  # Ручная смена
        use_line_numbers=False,
        comment_start="(",
        comment_end=")",
        dwell_unit="seconds",
        program_start=[
            "(DSP Controller Program)",
            "(Generated by Mebel-AI)",
            "G21",
            "G90",
        ],
        program_end=[
            "M05",
            "G00 Z10",
            "G00 X0 Y0",
            "M02",
        ],
    ),

    # -------------------------------------------------------------------------
    # HOMAG — ПРЕМИУМ мебельное оборудование
    # Высокоскоростные шпиндели, автоматические линии
    # -------------------------------------------------------------------------
    "homag": MachineProfile(
        name="HOMAG (woodWOP)",
        machine_type=MachineType.HOMAG,
        spindle_speed=24000,  # Высокоскоростной шпиндель
        feed_rate_cutting=1200,  # Высокая производительность
        feed_rate_plunge=600,
        feed_rate_drilling=400,
        safe_height=10.0,
        cut_depth=19.0,
        step_down=19.0,  # Один проход для ЛДСП
        tool_diameter=8.0,
        use_tool_change=True,
        use_line_numbers=True,
        line_number_increment=10,
        use_coolant=True,
        comment_start="(",
        comment_end=")",
        dwell_unit="seconds",
        program_start=[
            "%",
            "O1000",
            "(HOMAG Nesting Program)",
            "(Generated by Mebel-AI)",
            "G21 G90 G40 G49 G80",
            "G17",
            "G54",  # Рабочая система координат
        ],
        program_end=[
            "M05",
            "G53 G0 Z0",
            "G53 G0 X0 Y0",
            "M30",
            "%",
        ],
    ),
}

# Алиасы для обратной совместимости
MACHINE_PROFILES["nc_studio"] = MACHINE_PROFILES["weihong"]


@dataclass
class GCodePath:
    """Путь инструмента для G-code."""
    points: list[tuple[float, float]]
    is_closed: bool = True
    depth: float = 18.0
    operation: Literal["contour", "pocket", "drill"] = "contour"


@dataclass
class DrillPoint:
    """Точка сверления (присадка)."""
    x: float
    y: float
    diameter: float
    depth: float
    dwell: float = 0.0  # Задержка на дне (сек) — для G82


@dataclass
class ArcSegment:
    """Сегмент дуги для G02/G03."""
    start: tuple[float, float]
    end: tuple[float, float]
    center: tuple[float, float]
    clockwise: bool = True


@dataclass
class SlotPath:
    """Паз для фрезеровки (шипы, полки)."""
    start: tuple[float, float]
    end: tuple[float, float]
    width: float  # Ширина паза
    depth: float  # Глубина паза


class GCodeGenerator:
    """Генератор G-code для мебельного производства."""

    def __init__(self, profile: MachineProfile | str = "weihong"):
        if isinstance(profile, str):
            if profile not in MACHINE_PROFILES:
                available = list(MACHINE_PROFILES.keys())
                raise ValueError(f"Unknown profile: {profile}. Available: {available}")
            self.profile = MACHINE_PROFILES[profile]
        else:
            self.profile = profile

        self._output: list[str] = []
        self._line_number = 10
        self._current_z: float = self.profile.safe_height

    def _add_line(self, line: str, is_command: bool = True) -> None:
        """Добавляет строку в G-code."""
        if self.profile.use_line_numbers and is_command and line.strip() and not line.startswith(("%", "O")):
            line = f"N{self._line_number} {line}"
            self._line_number += self.profile.line_number_increment
        self._output.append(line)

    def _comment(self, text: str) -> str:
        """Форматирует комментарий."""
        return f"{self.profile.comment_start}{text}{self.profile.comment_end}"

    def _dwell(self, seconds: float) -> None:
        """Пауза G04 с учётом единиц измерения."""
        if self.profile.dwell_unit == "milliseconds":
            # Weihong: P в миллисекундах
            ms = int(seconds * 1000)
            self._add_line(f"G04 P{ms}")
        else:
            # FANUC/Syntec: P в секундах
            self._add_line(f"G04 P{seconds:.1f}")

    def _rapid(self, x: float | None = None, y: float | None = None, z: float | None = None) -> None:
        """Быстрое перемещение G00."""
        coords = []
        if x is not None:
            coords.append(f"X{x:.3f}")
        if y is not None:
            coords.append(f"Y{y:.3f}")
        if z is not None:
            coords.append(f"Z{z:.3f}")
            self._current_z = z

        if coords:
            self._add_line(f"G00 {' '.join(coords)}")

    def _linear(self, x: float | None = None, y: float | None = None, z: float | None = None,
                feed: int | None = None) -> None:
        """Линейная интерполяция G01."""
        coords = []
        if x is not None:
            coords.append(f"X{x:.3f}")
        if y is not None:
            coords.append(f"Y{y:.3f}")
        if z is not None:
            coords.append(f"Z{z:.3f}")
            self._current_z = z

        feed_str = f" F{feed}" if feed else ""
        if coords:
            self._add_line(f"G01 {' '.join(coords)}{feed_str}")

    def _arc(self, x: float, y: float, i: float, j: float, clockwise: bool = True,
             feed: int | None = None) -> None:
        """Круговая интерполяция G02/G03."""
        g_code = "G02" if clockwise else "G03"
        feed_str = f" F{feed}" if feed else ""
        self._add_line(f"{g_code} X{x:.3f} Y{y:.3f} I{i:.3f} J{j:.3f}{feed_str}")

    def _spindle_on(self) -> None:
        """Включить шпиндель M03."""
        self._add_line(f"S{self.profile.spindle_speed} M03")
        # Пауза для разгона шпинделя
        self._dwell(1.0)

    def _spindle_off(self) -> None:
        """Выключить шпиндель M05."""
        self._add_line("M05")

    def _tool_change(self, tool_number: int) -> None:
        """Смена инструмента M06."""
        if self.profile.use_tool_change:
            self._add_line(f"M06 T{tool_number:02d}")

    def _coolant_on(self) -> None:
        """Включить СОЖ M08."""
        if self.profile.use_coolant:
            self._add_line("M08")

    def _coolant_off(self) -> None:
        """Выключить СОЖ M09."""
        if self.profile.use_coolant:
            self._add_line("M09")

    def generate_contour(self, path: GCodePath) -> None:
        """Генерирует G-code для контурной резки (нестинг)."""
        if len(path.points) < 2:
            return

        self._add_line(self._comment(f"Contour: depth={path.depth}mm"), is_command=False)

        # Количество проходов по глубине
        num_passes = math.ceil(path.depth / self.profile.step_down)
        current_depth = 0.0

        for pass_num in range(num_passes):
            current_depth = min(current_depth + self.profile.step_down, path.depth)
            self._add_line(self._comment(f"Pass {pass_num + 1}/{num_passes}, Z=-{current_depth:.1f}"), is_command=False)

            # Перемещаемся к первой точке на безопасной высоте
            first_point = path.points[0]
            self._rapid(x=first_point[0], y=first_point[1])

            # Опускаемся на глубину резки
            self._rapid(z=self.profile.safe_height / 2)
            self._linear(z=-current_depth, feed=self.profile.feed_rate_plunge)

            # Режем по контуру
            for point in path.points[1:]:
                self._linear(x=point[0], y=point[1], feed=self.profile.feed_rate_cutting)

            # Замыкаем контур
            if path.is_closed and path.points[-1] != path.points[0]:
                self._linear(x=first_point[0], y=first_point[1], feed=self.profile.feed_rate_cutting)

            # Поднимаемся
            self._rapid(z=self.profile.safe_height)

    def generate_drilling(self, holes: list[DrillPoint]) -> None:
        """
        Генерирует G-code для сверления (присадка под фурнитуру).

        Циклы сверления:
        - G81: Простое сверление (неглубокие отверстия)
        - G82: Сверление с задержкой на дне (точные отверстия под петли)
        - G83: Глубокое сверление с выводом стружки (глубина > 2*peck)
        """
        if not holes:
            return

        self._add_line(self._comment(f"Drilling: {len(holes)} holes"), is_command=False)

        for i, hole in enumerate(holes):
            cycle_type = self._select_drill_cycle(hole)
            self._add_line(
                self._comment(f"Hole {i+1}: D={hole.diameter}mm, depth={hole.depth}mm, cycle={cycle_type}"),
                is_command=False
            )

            # Перемещаемся к точке сверления
            self._rapid(x=hole.x, y=hole.y)
            self._rapid(z=self.profile.drill_retract)

            # Выбираем цикл сверления
            # Приоритет: G82 (с задержкой) > G83 (глубокое) > G81 (простое)
            if hole.dwell > 0:
                # G82 — сверление с задержкой на дне (ПРИОРИТЕТ)
                # Для точных отверстий под петли (35мм), эксцентрики (15мм)
                dwell_param = self._format_dwell_param(hole.dwell)
                self._add_line(
                    f"G82 X{hole.x:.3f} Y{hole.y:.3f} Z{-hole.depth:.3f} "
                    f"R{self.profile.drill_retract:.1f} {dwell_param} "
                    f"F{self.profile.feed_rate_drilling}"
                )
            elif hole.depth > self.profile.drill_peck_depth * 2:
                # G83 — глубокое сверление с выводом стружки
                # Для глубоких отверстий (> 10мм в ЛДСП)
                self._add_line(
                    f"G83 X{hole.x:.3f} Y{hole.y:.3f} Z{-hole.depth:.3f} "
                    f"R{self.profile.drill_retract:.1f} Q{self.profile.drill_peck_depth:.1f} "
                    f"F{self.profile.feed_rate_drilling}"
                )
            else:
                # G81 — простое сверление
                # Для неглубоких отверстий без особых требований
                self._add_line(
                    f"G81 X{hole.x:.3f} Y{hole.y:.3f} Z{-hole.depth:.3f} "
                    f"R{self.profile.drill_retract:.1f} F{self.profile.feed_rate_drilling}"
                )

            # Отмена цикла
            self._add_line("G80")
            self._rapid(z=self.profile.safe_height)

    def _select_drill_cycle(self, hole: DrillPoint) -> str:
        """Определяет тип цикла сверления (приоритет: G82 > G83 > G81)."""
        if hole.dwell > 0:
            return "G82"
        if hole.depth > self.profile.drill_peck_depth * 2:
            return "G83"
        return "G81"

    def _format_dwell_param(self, seconds: float) -> str:
        """Форматирует параметр задержки для G82."""
        if self.profile.dwell_unit == "milliseconds":
            return f"P{int(seconds * 1000)}"
        return f"P{seconds:.1f}"

    def generate_arc(self, arc: ArcSegment, feed: int | None = None) -> None:
        """
        Генерирует G-code для дуги (G02/G03).

        G02 — по часовой стрелке
        G03 — против часовой стрелки

        Параметры I, J — смещение центра дуги от начальной точки.
        """
        # Вычисляем I, J — смещение центра от начальной точки
        i = arc.center[0] - arc.start[0]
        j = arc.center[1] - arc.start[1]

        feed_rate = feed or self.profile.feed_rate_cutting
        g_code = "G02" if arc.clockwise else "G03"

        self._add_line(
            f"{g_code} X{arc.end[0]:.3f} Y{arc.end[1]:.3f} I{i:.3f} J{j:.3f} F{feed_rate}"
        )

    def generate_slot(self, slot: SlotPath) -> None:
        """
        Генерирует G-code для фрезеровки паза (Slot Milling).

        Используется для:
        - Пазов под шипы
        - Пазов под полки
        - Канавок для задних стенок

        Стратегия: линейное движение вдоль паза с несколькими проходами по глубине.
        """
        self._add_line(
            self._comment(f"Slot: {slot.start} -> {slot.end}, width={slot.width}mm, depth={slot.depth}mm"),
            is_command=False
        )

        # Количество проходов по глубине
        num_passes = math.ceil(slot.depth / self.profile.step_down)
        current_depth = 0.0

        for pass_num in range(num_passes):
            current_depth = min(current_depth + self.profile.step_down, slot.depth)
            self._add_line(
                self._comment(f"Slot pass {pass_num + 1}/{num_passes}, Z=-{current_depth:.1f}"),
                is_command=False
            )

            # Перемещаемся к началу паза
            self._rapid(x=slot.start[0], y=slot.start[1])
            self._rapid(z=self.profile.safe_height / 2)

            # Врезаемся
            self._linear(z=-current_depth, feed=self.profile.feed_rate_plunge)

            # Фрезеруем паз
            self._linear(x=slot.end[0], y=slot.end[1], feed=self.profile.feed_rate_cutting)

            # Возвращаемся (для чистоты реза)
            self._linear(x=slot.start[0], y=slot.start[1], feed=self.profile.feed_rate_cutting)

            # Поднимаемся
            self._rapid(z=self.profile.safe_height)

    def generate_from_paths(
        self,
        paths: list[GCodePath],
        holes: list[DrillPoint] | None = None,
        arcs: list[ArcSegment] | None = None,
        slots: list[SlotPath] | None = None,
    ) -> str:
        """Генерирует полную G-code программу."""
        self._output = []
        self._line_number = 10

        # Заголовок программы
        for line in self.profile.program_start:
            self._add_line(line, is_command=False)

        # Информация о задании
        self._add_line(self._comment(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M')}"), is_command=False)
        self._add_line(self._comment(f"Profile: {self.profile.name}"), is_command=False)
        self._add_line(self._comment(f"Tool: D{self.profile.tool_diameter}mm"), is_command=False)

        # Смена инструмента
        self._tool_change(self.profile.tool_number)

        # Включаем шпиндель
        self._spindle_on()
        self._coolant_on()

        # Безопасная высота
        self._rapid(z=self.profile.safe_height)

        # Генерируем контуры
        for i, path in enumerate(paths):
            self._add_line("", is_command=False)
            self._add_line(self._comment(f"=== Path {i+1}/{len(paths)} ==="), is_command=False)
            self.generate_contour(path)

        # Генерируем пазы (Slot Milling)
        if slots:
            self._add_line("", is_command=False)
            self._add_line(self._comment("=== Slots (Пазы) ==="), is_command=False)
            for i, slot in enumerate(slots):
                self._add_line(self._comment(f"Slot {i+1}/{len(slots)}"), is_command=False)
                self.generate_slot(slot)

        # Генерируем сверление
        if holes:
            self._add_line("", is_command=False)
            self._add_line(self._comment("=== Drilling (Присадка) ==="), is_command=False)
            self.generate_drilling(holes)

        # Завершение
        self._coolant_off()
        self._spindle_off()

        self._add_line("", is_command=False)
        for line in self.profile.program_end:
            self._add_line(line, is_command=False)

        return "\n".join(self._output)


@dataclass
class DXFExtractResult:
    """Результат извлечения данных из DXF."""
    paths: list[GCodePath]
    holes: list[DrillPoint]
    arcs: list[ArcSegment]
    slots: list[SlotPath]


def extract_paths_from_dxf(dxf_data: bytes) -> tuple[list[GCodePath], list[DrillPoint]]:
    """
    Извлекает пути и точки сверления из DXF файла.
    Обратная совместимость — возвращает только paths и holes.
    """
    result = extract_all_from_dxf(dxf_data)
    return result.paths, result.holes


def extract_all_from_dxf(dxf_data: bytes) -> DXFExtractResult:
    """
    Извлекает все данные из DXF файла.

    Слои в DXF (из dxf_generator.py):
    - CONTOUR: внешние контуры панелей (полилинии, линии)
    - DRILLING: отверстия для фурнитуры (круги)
    - SLOT: пазы (линии)
    - EDGE: кромка (игнорируется)
    - TEXT: надписи (игнорируются)

    Также извлекает:
    - ARC на любом слое → G02/G03
    """
    if not EZDXF_AVAILABLE:
        raise RuntimeError("ezdxf is required for DXF parsing")

    # ezdxf ожидает текстовый поток, декодируем bytes
    stream = io.StringIO(dxf_data.decode("utf-8"))
    doc = ezdxf.read(stream)
    msp = doc.modelspace()

    paths: list[GCodePath] = []
    holes: list[DrillPoint] = []
    arcs: list[ArcSegment] = []
    slots: list[SlotPath] = []

    # Извлекаем контуры (слой CONTOUR)
    for entity in msp.query("LWPOLYLINE[layer=='CONTOUR']"):
        points = [(p[0], p[1]) for p in entity.get_points()]
        if len(points) >= 2:
            paths.append(GCodePath(
                points=points,
                is_closed=entity.closed,
                depth=18.0,
                operation="contour"
            ))

    # Линии на слое CONTOUR
    for entity in msp.query("LINE[layer=='CONTOUR']"):
        start = (round(entity.dxf.start.x, 3), round(entity.dxf.start.y, 3))
        end = (round(entity.dxf.end.x, 3), round(entity.dxf.end.y, 3))
        paths.append(GCodePath(
            points=[start, end],
            is_closed=False,
            depth=18.0,
            operation="contour"
        ))

    # Извлекаем дуги (ARC) → G02/G03
    for entity in msp.query("ARC"):
        center = entity.dxf.center
        radius = entity.dxf.radius
        start_angle = math.radians(entity.dxf.start_angle)
        end_angle = math.radians(entity.dxf.end_angle)

        # Вычисляем начальную и конечную точки дуги
        start_point = (
            round(center.x + radius * math.cos(start_angle), 3),
            round(center.y + radius * math.sin(start_angle), 3),
        )
        end_point = (
            round(center.x + radius * math.cos(end_angle), 3),
            round(center.y + radius * math.sin(end_angle), 3),
        )

        # Определяем направление (по часовой / против)
        # В DXF дуги идут против часовой по умолчанию
        clockwise = False

        arcs.append(ArcSegment(
            start=start_point,
            end=end_point,
            center=(round(center.x, 3), round(center.y, 3)),
            clockwise=clockwise,
        ))

    # Извлекаем отверстия (слой DRILLING)
    for entity in msp.query("CIRCLE[layer=='DRILLING']"):
        center = entity.dxf.center
        radius = entity.dxf.radius
        diameter = radius * 2

        # Определяем нужна ли задержка (G82) для точных отверстий
        # Отверстия под петли (35мм) и эксцентрики (15мм) требуют задержку
        dwell = 0.5 if diameter in (15.0, 35.0) else 0.0

        holes.append(DrillPoint(
            x=round(center.x, 3),
            y=round(center.y, 3),
            diameter=diameter,
            depth=DEFAULT_DRILLING_DEPTH,
            dwell=dwell,
        ))

    # Извлекаем пазы (слой SLOT)
    for entity in msp.query("LINE[layer=='SLOT']"):
        start = (round(entity.dxf.start.x, 3), round(entity.dxf.start.y, 3))
        end = (round(entity.dxf.end.x, 3), round(entity.dxf.end.y, 3))
        slots.append(SlotPath(
            start=start,
            end=end,
            width=DEFAULT_BACK_SLOT_WIDTH_MM,
            depth=DEFAULT_BACK_SLOT_DEPTH_MM,
        ))

    return DXFExtractResult(
        paths=paths,
        holes=holes,
        arcs=arcs,
        slots=slots,
    )


def dxf_to_gcode(
    dxf_data: bytes,
    machine_profile: str = "weihong",
    cut_depth: float | None = None,
    custom_profile: MachineProfile | None = None,
    drilling_only: bool = True,
) -> str:
    """
    Конвертирует DXF файл в G-code.

    Args:
        dxf_data: Содержимое DXF файла в bytes
        machine_profile: Название профиля (weihong, syntec, fanuc, dsp, homag)
        cut_depth: Глубина резки (переопределяет профиль)
        custom_profile: Пользовательский профиль станка
        drilling_only: Генерировать только присадку (сверление + пазы).
                       По умолчанию True — контурная резка выполняется
                       на форматнике по PDF карте раскроя.

    Returns:
        G-code программа в виде строки

    Режимы работы:
        drilling_only=True (по умолчанию):
            - Сверление (DRILLING layer): G81/G82/G83
            - Фрезеровка пазов под заднюю стенку (SLOT layer)
            - Контуры и дуги ИГНОРИРУЮТСЯ (резка на форматнике)

        drilling_only=False (для станков с нестингом):
            - Контурная резка (CONTOUR layer) → G00/G01
            - Круговая интерполяция (ARC entities) → G02/G03
            - Фрезеровка пазов (SLOT layer)
            - Сверление (DRILLING layer)
    """
    result = extract_all_from_dxf(dxf_data)

    profile = custom_profile if custom_profile else machine_profile
    generator = GCodeGenerator(profile)

    if drilling_only:
        # Режим "только присадка" — для станков где раскрой делается на форматнике
        # Генерируем только сверление и пазы, контуры игнорируем
        return generator.generate_from_paths(
            paths=[],  # Контуры не нужны — резка на форматнике
            holes=result.holes,
            arcs=[],  # Дуги относятся к контурам
            slots=result.slots,  # Пазы под заднюю стенку нужны
        )
    else:
        # Полный режим — для нестинг-станков (HOMAG и т.п.)
        if cut_depth is not None:
            for path in result.paths:
                path.depth = cut_depth

        return generator.generate_from_paths(
            paths=result.paths,
            holes=result.holes,
            arcs=result.arcs,
            slots=result.slots,
        )


def get_available_profiles() -> list[dict]:
    """Возвращает список доступных профилей станков."""
    result = []
    seen = set()

    for key, profile in MACHINE_PROFILES.items():
        # Пропускаем алиасы
        if profile.name in seen:
            continue
        seen.add(profile.name)

        result.append({
            "id": key,
            "name": profile.name,
            "machine_type": profile.machine_type.value,
            "spindle_speed": profile.spindle_speed,
            "feed_rate_cutting": profile.feed_rate_cutting,
            "tool_diameter": profile.tool_diameter,
            "dwell_unit": profile.dwell_unit,
            "market_share": _get_market_share(key),
        })

    return result


def _get_market_share(profile_id: str) -> str:
    """Возвращает долю рынка для профиля."""
    shares = {
        "weihong": "30-35%",
        "syntec": "20-25%",
        "fanuc": "15-20%",
        "dsp": "8-12%",
        "homag": "2-3%",
    }
    return shares.get(profile_id, "N/A")
